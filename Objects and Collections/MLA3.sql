--MANUEL LOPEZ 
--ASSIGN 3

--SQL QUERIES
SELECT * FROM ITEM_ASSEMBLY;
SELECT * FROM BICYCLE_ITEM;

---------------------------------
SET SERVEROUTPUT ON SIZE 10000;
SET LINESIZE 5000;
SPOOL C:/TEMP/ML3.out REPLACE;
--CALLER
DECLARE
  LISTTEMP ITEM_LIST_T := ITEM_LIST_T();
BEGIN
  DBMS_OUTPUT.PUT_LINE('Username is: ' || USER );
  DBMS_OUTPUT.PUT_LINE('Today''s DATE IS ' || SYSDATE );
  DBMS_OUTPUT.PUT_LINE('');
  
  LISTTEMP := ITEM_LIST_T();
  BOM.MLBOM(10, NULL, NULL, 0, LISTTEMP);
  DISPLAY(LISTTEMP);
  
  BOM.MLBOM(11, NULL, NULL, 0, LISTTEMP);
  DISPLAY(LISTTEMP);
  
  BOM.MLBOM(21, NULL, NULL, 0, LISTTEMP);
  DISPLAY(LISTTEMP);
  
  BOM.MLBOM(43, NULL, NULL, 0, LISTTEMP);
END;






--PACKAGE
DROP PACKAGE BODY BOM;
DROP PACKAGE BOM;

CREATE OR REPLACE PACKAGE BOM
IS
  PROCEDURE MLBOM(ITEM_TO_FIND_IN IN INTEGER, PENDANT_IN IN ITEM_LIST_T, VERIFIED_IN IN ITEM_LIST_T, 
    COUNTER_IN IN INTEGER, RES OUT ITEM_LIST_T);
END;

CREATE OR REPLACE PACKAGE BODY BOM 
IS
  PROCEDURE MLBOM(ITEM_TO_FIND_IN IN INTEGER, PENDANT_IN IN ITEM_LIST_T, VERIFIED_IN IN ITEM_LIST_T, 
    COUNTER_IN IN INTEGER, RES OUT ITEM_LIST_T)
  IS
    TEMPLIST ITEM_LIST_T;--THE CHILDS OF CURRENT 'ITEM_TO_FIND_IN' 
    
    VERIFIED ITEM_LIST_T;--ITEM THAT WERE CHECKED 
    PENDANT ITEM_LIST_T;--ITEMS THAT STILL ARE NOT BEING CHECKED
    COUNTER INTEGER;--THE COUNTER OF 'PENDANT'
  BEGIN
    --LISTS
    TEMPLIST := FIND_CHILD_OBJ(ITEM_TO_FIND_IN);
    --SO THE FIRST ITEM IS NOT ADDED TO VERIFIED LIST
    IF COUNTER_IN > 0 THEN
      VERIFIED := ADD_ITEM_TO_LIST(ITEM_TO_FIND_IN, VERIFIED_IN);
    ELSE
      VERIFIED := NEW ITEM_LIST_T();
    END IF;
    PENDANT := ADD_LIST_TO_LIST(TEMPLIST, PENDANT_IN);
    
    COUNTER := COUNTER_IN + 1;
    
    
    IF COUNTER <= PENDANT.COUNT THEN
       --RECURSIVE CALL
       MLBOM(PENDANT(COUNTER).ID, PENDANT, VERIFIED, COUNTER, RES);
    ELSIF COUNTER > PENDANT.COUNT AND VERIFIED.COUNT > 0 THEN
       --DONE
       VERIFIED := SIMPLIFY_LIST(VERIFIED);
       DBMS_OUTPUT.PUT_LINE('Assemblies for Item_Id: ' || VERIFIED(1).PARENT_ID || 
       ' ('  || FIND_MY_DESCRIP(VERIFIED(1).PARENT_ID) || ')');
       
       RES := VERIFIED;
            
    ELSIF VERIFIED.COUNT = 0 THEN
       --THAT ITEM HAS NOT ASSEMBLIES
       DBMS_OUTPUT.PUT_LINE('Item_Id: ' || ITEM_TO_FIND_IN || 
       ' ('  || FIND_MY_DESCRIP(ITEM_TO_FIND_IN) || ')' || ', has not assemblies');
    END IF;
  END;
END BOM;



--WILL PRINT TO SCREEN
CREATE OR REPLACE PROCEDURE DISPLAY(TO_DISP IN ITEM_LIST_T)
IS
  COUNTER INTEGER := 1;
BEGIN

  LOOP
    EXIT WHEN TO_DISP IS NULL OR COUNTER > TO_DISP.COUNT;
      
      DBMS_OUTPUT.PUT_LINE('Id: ' || TO_DISP(COUNTER).ID || 
        '  Quantity: ' || TO_DISP(COUNTER).QTY || '  Description: ' || TO_DISP(COUNTER).DESCRIPTION);
    
    COUNTER := COUNTER + 1;
  END LOOP;
  
  DBMS_OUTPUT.PUT_LINE('');
END;





--WILL BUILD OBJECT OF TYPE ITEM WITH ID ONLY
CREATE OR REPLACE FUNCTION CREATE_ITEM_OBJ(ITEM_ID_IN IN INTEGER)
  RETURN ITEM_T
IS
  RESULT ITEM_T;
  
  CURSOR CUR(ITEM_ID_C IN INTEGER) IS
      SELECT * FROM ITEM_ASSEMBLY WHERE ITEM_ID = ITEM_ID_C;
      
  CUR_ROW CUR%ROWTYPE;
  DESCRIPT BICYCLE_ITEM.ITEM_DESC%TYPE;

BEGIN

  OPEN CUR(ITEM_ID_IN);
      FETCH CUR INTO CUR_ROW;
      
      IF CUR%FOUND THEN
        DESCRIPT := FIND_MY_DESCRIP(CUR_ROW.ITEM_ID);
        RESULT := NEW ITEM_T(CUR_ROW.ITEM_ID, CUR_ROW.PARENT_ITEM_ID, CUR_ROW.ASSEMBLY_QTY, DESCRIPT);
      ELSIF CUR%NOTFOUND THEN 
        --TO ADDRESS AN ITEM THAT DOESNT HAVE A PARENT
        DESCRIPT := FIND_MY_DESCRIP(ITEM_ID_IN);
        RESULT := NEW ITEM_T(ITEM_ID_IN, 0, 1, DESCRIPT);
      END IF;

  CLOSE CUR;


  RETURN RESULT;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unknown error ocurred. CREATE_ITEM_OBJ()');
    RETURN RESULT;
END;



--FUNCTION THT WILL DETECT AND SIMPLIFY DOUBLE ITEMS IN A LIST
CREATE OR REPLACE FUNCTION SIMPLIFY_LIST(TEMP_LIST_IN IN ITEM_LIST_T)
  RETURN ITEM_LIST_T
IS
  RESULT ITEM_LIST_T := ITEM_LIST_T();
  FOUND BOOLEAN := FALSE;
  COUNTER INTEGER := 1;
  INNER_COUNTER INTEGER := 1;
  
BEGIN
    
    LOOP
      EXIT WHEN COUNTER > TEMP_LIST_IN.COUNT;
      
        LOOP
          
          EXIT WHEN RESULT.COUNT = 0;
          EXIT WHEN INNER_COUNTER > RESULT.COUNT;
          
          IF TEMP_LIST_IN(COUNTER).ID = RESULT(INNER_COUNTER).ID THEN
            --SAME PART FOUND
            RESULT(INNER_COUNTER).QTY := RESULT(INNER_COUNTER).QTY + TEMP_LIST_IN(COUNTER).QTY;
            FOUND := TRUE;
          END IF;
          
          INNER_COUNTER := INNER_COUNTER + 1;
        END LOOP;
        
      --PROD NOT MACHT FOUND
      IF FOUND = FALSE THEN
        RESULT.EXTEND;
        RESULT(RESULT.LAST) := TEMP_LIST_IN(COUNTER);
      END IF;

      --LOOP MAINTANENCE 
      FOUND := FALSE;
      INNER_COUNTER := 1;
      COUNTER := COUNTER + 1;
    
    END LOOP;
   
  RETURN RESULT;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unknown error ocurred. SIMPLIFY_LIST()');
    RETURN RESULT;
END;







--WILL ADD AN OBJ TO THE LIST PASS AND WILL RETURN LIST
CREATE OR REPLACE FUNCTION ADD_ITEM_TO_LIST(ITEM_ID_IN IN INTEGER, LIST_IN ITEM_LIST_T)
  RETURN ITEM_LIST_T
IS
  RESULT ITEM_LIST_T;
BEGIN

    IF LIST_IN IS NULL THEN
      RESULT := NEW ITEM_LIST_T();
    ELSIF LIST_IN IS NOT NULL THEN
      RESULT := LIST_IN;
    END IF;
    
    RESULT.EXTEND;
    RESULT(RESULT.LAST) := CREATE_ITEM_OBJ(ITEM_ID_IN);
   
  RETURN RESULT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE ('Value: ' || ITEM_ID_IN || ' not found');
    RETURN LIST_IN;
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unknown error ocurred. ADD_ITEM_TO_LIST()');
    RETURN LIST_IN;
END;




--WILL ADD A LIST TO THE LIST, AND WILL RETURN THE BOTH 
CREATE OR REPLACE FUNCTION ADD_LIST_TO_LIST(TEMP_LIST_IN IN ITEM_LIST_T, LIST_IN IN ITEM_LIST_T)
  RETURN ITEM_LIST_T
IS
  RESULT ITEM_LIST_T;
  COUNTER INTEGER := 1;
BEGIN

    IF LIST_IN IS NULL THEN
      RESULT := NEW ITEM_LIST_T();
    ELSIF LIST_IN IS NOT NULL THEN
      RESULT := LIST_IN;
    END IF;
    
    LOOP
      
      EXIT WHEN COUNTER > TEMP_LIST_IN.COUNT;
      
      IF TEMP_LIST_IN(COUNTER) IS NOT NULL 
      THEN
        RESULT.EXTEND;
        RESULT(RESULT.LAST) := TEMP_LIST_IN(COUNTER);
      END IF;
      COUNTER := COUNTER + 1;
    
    END LOOP;
   
  RETURN RESULT;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unknown error ocurred. ADD_LIST_TO_LIST()');
    RETURN LIST_IN;
END;






--WILL FIND THE CHILD OBJECTS OF 'ITEM_ID'
CREATE OR REPLACE FUNCTION FIND_CHILD_OBJ(ITEM_ID IN INTEGER)
  RETURN ITEM_LIST_T
IS
  RESULT ITEM_LIST_T;
  HOLD ITEM_T;
  
  CURSOR CUR(ITEM_ID_IN IN INTEGER) IS
      SELECT * FROM ITEM_ASSEMBLY WHERE PARENT_ITEM_ID = ITEM_ID_IN;
      
  CUR_ROW CUR%ROWTYPE;
  
  DESCRIPT BICYCLE_ITEM.ITEM_DESC%TYPE;
      
BEGIN

    RESULT := NEW ITEM_LIST_T();
    OPEN CUR(ITEM_ID);
    LOOP

        FETCH CUR INTO CUR_ROW;
        EXIT WHEN CUR%NOTFOUND;
        
        RESULT.EXTEND;
        
        DESCRIPT := FIND_MY_DESCRIP(CUR_ROW.ITEM_ID);
  
        HOLD :=  NEW ITEM_T(CUR_ROW.ITEM_ID, CUR_ROW.PARENT_ITEM_ID, CUR_ROW.ASSEMBLY_QTY, DESCRIPT);
        RESULT(RESULT.LAST) := HOLD;

    END LOOP;
    CLOSE CUR;

  RETURN RESULT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE ('Value: ' || ITEM_ID || ' not found');
    RETURN RESULT;
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unknown error ocurred. FIND_CHILD_OBJ()');
    RETURN RESULT;
END;



--FIND THE DESCRIPTION OF 'ITEM_ID_IN'
CREATE OR REPLACE FUNCTION FIND_MY_DESCRIP(ITEM_ID_IN IN INTEGER) 
  RETURN VARCHAR2
IS 
  RESULT BICYCLE_ITEM.ITEM_DESC%TYPE;
BEGIN
    SELECT ITEM_DESC FETCH INTO RESULT FROM BICYCLE_ITEM B WHERE B.ITEM_ID = ITEM_ID_IN;
    
    IF RESULT IS NULL THEN
      RESULT := '';
    END IF;
    
    RETURN RESULT;
EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE( 'Unknown exception in PL/SQL function. FIND_MY_DESCRIP().');
      RETURN RESULT;
END;



--OBJECT TYPE class
CREATE OR REPLACE TYPE ITEM_T AS OBJECT (
  ID INTEGER, 
	PARENT_ID INTEGER,
	QTY INTEGER,
  DESCRIPTION VARCHAR(60)
);



--COLLECTION TYPE
DROP TYPE ITEM_LIST_T;
CREATE OR REPLACE TYPE ITEM_LIST_T IS TABLE OF ITEM_T;